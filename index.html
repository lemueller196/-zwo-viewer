<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<title>Zwo Workout Viewer</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; }
  h1 { font-size: 1.5em; margin-bottom: 10px; }
  #controls { display:flex; gap:10px; align-items:center; margin-bottom:15px; flex-wrap:wrap; }
  #workoutCharts { display:flex; flex-wrap:wrap; gap:5px; align-items:flex-end; }
  .workoutContainer { flex:1 1 23%; max-width:23%; min-width:120px; display:flex; flex-direction:column; align-items:flex-start; text-align:left; }
  .workoutName { font-size:0.85em; margin-bottom:2px; white-space:pre-line; line-height:1.15; cursor:pointer; color:#0056b3; text-align:left; }
  .workoutName:hover { text-decoration:underline; }
  .groupRow { flex-basis:100%; height:0; margin:10px 0; }
  canvas { width:100% !important; height:150px !important; }
  button { padding:6px 10px; border:1px solid #007bff; background:#007bff; color:white; border-radius:4px; cursor:pointer; font-size:0.9em; }
  button:hover { background:#0056b3; }
</style>
</head>
<body>
<h1>Zwo Workout Viewer</h1>
<div id="controls">
  <input type="file" id="fileInput" accept=".zwo" multiple>
  <button id="loadFromGitHub">Workouts von GitHub laden</button>
</div>
<div id="workoutCharts"></div>

<script>
const fileInput = document.getElementById('fileInput');
const workoutChartsContainer = document.getElementById('workoutCharts');

// === Farben nach Leistungszonen ===
function getZoneColor(p, alpha = 1) {
  if (p < 0.60) return `rgba(108,117,125,${alpha})`;
  if (p < 0.76) return `rgba(0,123,255,${alpha})`;
  if (p < 0.90) return `rgba(40,167,69,${alpha})`;
  if (p < 1.05) return `rgba(255,193,7,${alpha})`;
  if (p < 1.18) return `rgba(255,87,34,${alpha})`;
  return `rgba(220,53,69,${alpha})`;
}

// === Verarbeitung lokaler Dateien ===
fileInput.addEventListener('change', (ev) => {
  const files = Array.from(ev.target.files);
  // Alphabetisch-numerisch sortieren (59min < 120min)
  files.sort((a, b) => a.name.localeCompare(b.name, 'de', { numeric: true, sensitivity: 'base' }));
  processWorkouts(files);
});

// === Verarbeitung von GitHub-Dateien ===
document.getElementById('loadFromGitHub').addEventListener('click', async () => {
  workoutChartsContainer.innerHTML = '<p>Lade Workouts von GitHub...</p>';

  try {
    const apiUrl = 'https://api.github.com/repos/lemueller196/-zwo-viewer/contents/workouts';
    const res = await fetch(apiUrl);
    if (!res.ok) throw new Error('GitHub API-Fehler');
    const list = await res.json();

    const zwoFiles = list.filter(f => f.name.toLowerCase().endsWith('.zwo'));
    if (!zwoFiles.length) {
      workoutChartsContainer.innerHTML = '<p>Keine .zwo-Dateien im GitHub-Ordner gefunden.</p>';
      return;
    }

    // Alphabetisch-numerisch sortieren (59min < 120min)
    zwoFiles.sort((a, b) => a.name.localeCompare(b.name, 'de', { numeric: true, sensitivity: 'base' }));

    const fakeFiles = [];
    for (const f of zwoFiles) {
      const fileUrl = f.download_url;
      const text = await (await fetch(fileUrl)).text();
      fakeFiles.push(new File([text], f.name, { type: 'text/plain' }));
    }

    processWorkouts(fakeFiles);
  } catch (err) {
    console.error(err);
    workoutChartsContainer.innerHTML = '<p>Fehler beim Laden der Dateien von GitHub.</p>';
  }
});

// === Hauptverarbeitungsfunktion ===
async function processWorkouts(files) {
  if (!files.length) return;
  workoutChartsContainer.innerHTML = '';

  // Gruppiere Dateien nach Präfix
  const groups = {};
  for (const f of files) {
    const base = f.name.replace(/^Eiche_/, '').replace(/\.zwo$/i, '');
    const groupKey = base.split('_')[0];
    if (!groups[groupKey]) groups[groupKey] = [];
    groups[groupKey].push(f);
  }

  // Hilfsfunktion für Rampen
  function interpolate(start, end, steps) {
    const r = [];
    for (let i = 0; i < steps; i++) r.push(start + (end - start) * (i / steps));
    return r;
  }

  for (const groupName of Object.keys(groups)) {
    // Zeilen-Trenner
    const separator = document.createElement('div');
    separator.className = 'groupRow';
    workoutChartsContainer.appendChild(separator);

    for (const file of groups[groupName]) {
      const text = await file.text();
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(text, "text/xml");
      const workoutSteps = xmlDoc.querySelectorAll('workout > *:not(name)');

      const data = [];
      const stepPowers = [];

      for (let step of workoutSteps) {
        const type = step.tagName;
        const duration = parseFloat(step.getAttribute('Duration')) || 0;
        const segmentCount = Math.max(Math.floor(duration / 5), 1);

        if (type === 'SteadyState') {
          const power = parseFloat(step.getAttribute('Power')) || 0;
          data.push(...Array(segmentCount).fill(power));
          stepPowers.push(...Array(segmentCount).fill().map(()=>({type, power})));
        } else if (type === 'Warmup' || type === 'Cooldown' || type === 'Ramp') {
          const powerLow = parseFloat(step.getAttribute('PowerLow')) || 0;
          const powerHigh = parseFloat(step.getAttribute('PowerHigh')) || powerLow;
          const powers = interpolate(powerLow, powerHigh, segmentCount);
          data.push(...powers);
          stepPowers.push(...powers.map(p=>({type, power:p})));
        } else if (type === 'IntervalsT') {
          const repeat = parseInt(step.getAttribute('Repeat')) || 1;
          const onDur = parseFloat(step.getAttribute('OnDuration')) || 0;
          const offDur = parseFloat(step.getAttribute('OffDuration')) || 0;
          const onPower = parseFloat(step.getAttribute('OnPower')) || 0;
          const offPower = parseFloat(step.getAttribute('OffPower')) || 0;
          for (let r = 0; r < repeat; r++) {
            const onCount = Math.max(Math.floor(onDur / 5),1);
            const offCount = Math.max(Math.floor(offDur / 5),1);
            data.push(...Array(onCount).fill(onPower));
            stepPowers.push(...Array(onCount).fill().map(()=>({type, power:onPower})));
            data.push(...Array(offCount).fill(offPower));
            stepPowers.push(...Array(offCount).fill().map(()=>({type, power:offPower})));
          }
        } else {
          const power = parseFloat(step.getAttribute('Power')) || 0;
          data.push(...Array(segmentCount).fill(power));
          stepPowers.push(...Array(segmentCount).fill().map(()=>({type, power})));
        }
      }

      const labels = data.map((_,i)=> i * 5 / 60);

      let fullName = file.name.replace(/^Eiche_/, '').replace(/\.zwo$/i, '');
      fullName = fullName.replace(/(min_)/, "$1\n");
      fullName = fullName.replace(/_(.{2,3}TSS)/, "\n_$1");

      const container = document.createElement('div');
      container.className = 'workoutContainer';

      const nameEl = document.createElement('h2');
      nameEl.className = 'workoutName';
      nameEl.textContent = fullName;
      container.appendChild(nameEl);

      const canvas = document.createElement('canvas');
      container.appendChild(canvas);
      workoutChartsContainer.appendChild(container);

      const ctx = canvas.getContext('2d');
      const maxY = Math.ceil(Math.max(...data) * 10) / 10;

      const chart = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets: [{
          label:'', data,
          tension:0.3, pointRadius:0, pointHoverRadius:6, borderWidth:1.5, fill:true,
          pointHoverBackgroundColor: ctx => {
            const idx = ctx.dataIndex;
            if (idx==null) return 'rgba(0,0,0,0.8)';
            return getZoneColor(stepPowers[idx].power, 1);
          },
          segment: {
            borderColor: ctx => {
              const s0 = stepPowers[ctx.p0DataIndex];
              const s1 = stepPowers[ctx.p1DataIndex];
              if (!s0 || !s1) return 'rgba(0,0,0,0)';
              return getZoneColor(Math.max(s0.power, s1.power), 1);
            },
            backgroundColor: ctx => {
              const s0 = stepPowers[ctx.p0DataIndex];
              const s1 = stepPowers[ctx.p1DataIndex];
              if (!s0 || !s1) return 'rgba(0,0,0,0)';
              return getZoneColor(Math.max(s0.power, s1.power), 0.28);
            }
          }
        }]},
        options: {
          maintainAspectRatio:false,
          interaction:{mode:'nearest', intersect:false},
          plugins:{
            legend:{display:false},
            tooltip:{
              enabled:true,
              backgroundColor:'rgba(20,20,20,0.85)',
              bodyFont:{size:11},
              displayColors:false,
              callbacks:{ label: item => 'Leistung: ' + Math.round(item.raw*100) + '%' }
            }
          },
          scales:{
            x:{ type:'linear', min:0, ticks:{ stepSize:5, font:{ size: 10 } }},
            y:{ min:0.4, max:maxY, ticks:{ callback: v => Math.round(v*100)+'%', stepSize:0.1, font:{ size: 10 } } }
          }
        }
      });

      // Hover-Tooltip
      container.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        let x = e.clientX - rect.left;
        x = Math.max(0, Math.min(x, rect.width));
        const xVal = chart.scales.x.getValueForPixel(x);
        let nearest = 0, minDist = Infinity;
        chart.data.labels.forEach((lbl,i) => { const d = Math.abs(lbl - xVal); if (d < minDist) { minDist = d; nearest = i; } });
        const active = [{ datasetIndex: 0, index: nearest }];
        chart.tooltip.setActiveElements(active, {x, y: 0});
        chart.update('none');
      });
      container.addEventListener('mouseleave', () => {
        chart.tooltip.setActiveElements([], {x:0,y:0});
        chart.update('none');
      });

      // Klick → großes Diagramm
      nameEl.addEventListener('click', async () => {
		const text = await file.text();
		openBigChart(fullName, data, labels, stepPowers, file.name, text);
	  });
    }
  }
}

// === Hilfsfunktionen ===
function escapeHtml(s){
  return String(s)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}

function openBigChart(fullName, data, labels, stepPowers, fileName, fileContent){
  const titleHTML = fullName.replace(/\n/g, '<br>');
  const dataStr = JSON.stringify(data);
  const labelsStr = JSON.stringify(labels);
  const stepPowersStr = JSON.stringify(stepPowers);
  const fileNameStr = JSON.stringify(fileName);
  const fileContentStr = JSON.stringify(fileContent);

  const html = `<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<title>${escapeHtml(fullName)}</title>
<style>
  html,body { height:100%; margin:0; overflow:hidden; font-family: Arial, sans-serif; }
  body { display:flex; flex-direction:column; gap:10px; align-items:center; justify-content:flex-start; padding:10px; box-sizing:border-box; }
  h2 { margin:0; font-size:1.1em; text-align:center; white-space:pre-line; }
  #chartWrap { width:100vw; height:calc(100vh - 60px); display:flex; align-items:center; justify-content:center; }
  canvas { width: calc(100vw - 20px); height: calc(100vh - 80px); }
</style>
</head>
<body>
<div id="topBar" style="display:flex;justify-content:space-between;align-items:center;width:100%;max-width:900px;">
  <h2 style="margin:0;font-size:1.1em;text-align:center;white-space:pre-line;">${titleHTML}</h2>
  <button id="downloadBtn" style="padding:6px 12px;border:1px solid #007bff;background:#007bff;color:white;border-radius:4px;cursor:pointer;font-size:0.9em;">
    ZWO-Datei herunterladen
  </button>
</div>
<div id="chartWrap"><canvas id="bigChart"></canvas></div>
<script src="https://cdn.jsdelivr.net/npm/chart.js"><\/script>
<script>
(function(){
  const data = ${dataStr};
  const labels = ${labelsStr};
  const stepPowers = ${stepPowersStr};
  const fileName = ${fileNameStr};
  const fileContent = ${fileContentStr};

  function getZoneColor(p, alpha=1){
    if (p < 0.60) return 'rgba(108,117,125,'+alpha+')';
    if (p < 0.76) return 'rgba(0,123,255,'+alpha+')';
    if (p < 0.90) return 'rgba(40,167,69,'+alpha+')';
    if (p < 1.05) return 'rgba(255,193,7,'+alpha+')';
    if (p < 1.18) return 'rgba(255,87,34,'+alpha+')';
    return 'rgba(220,53,69,'+alpha+')';
  }

  // Download-Button aktivieren
  const _zwoBlob = new Blob([fileContent], { type: 'text/plain' });
  const _zwoUrl = URL.createObjectURL(_zwoBlob);

  document.getElementById('downloadBtn').addEventListener('click', () => {
    const a = document.createElement('a');
    a.href = _zwoUrl;
    a.download = fileName || 'workout.zwo';
    a.click();
  });

  window.addEventListener('unload', () => {
    URL.revokeObjectURL(_zwoUrl);
  });

  const ctx = document.getElementById('bigChart').getContext('2d');
  const maxY = Math.ceil(Math.max(...data) * 10) / 10;

  new Chart(ctx, {
    type:'line',
    data:{ labels, datasets:[{
      label:'', data,
      tension:0.22,
      pointRadius:0,
      pointHoverRadius:7,
      borderWidth:2,
      fill:true,
      pointHoverBackgroundColor: ctx => {
        const idx = ctx.dataIndex;
        if (idx == null) return 'rgba(0,0,0,0.8)';
        return getZoneColor(stepPowers[idx].power, 1);
      },
      pointHoverBorderColor: ctx => {
        const idx = ctx.dataIndex;
        if (idx == null) return 'rgba(0,0,0,0.8)';
        return getZoneColor(stepPowers[idx].power, 1);
      },
      segment:{
        borderColor: ctx => {
          const s0 = stepPowers[ctx.p0DataIndex];
          const s1 = stepPowers[ctx.p1DataIndex];
          if (!s0 || !s1) return 'rgba(0,0,0,0)';
          return getZoneColor(Math.max(s0.power, s1.power), 1);
        },
        backgroundColor: ctx => {
          const s0 = stepPowers[ctx.p0DataIndex];
          const s1 = stepPowers[ctx.p1DataIndex];
          if (!s0 || !s1) return 'rgba(0,0,0,0)';
          return getZoneColor(Math.max(s0.power, s1.power), 0.28);
        }
      }
    }]},
    options:{
      responsive:true,
      maintainAspectRatio:false,
      plugins:{
        legend:{ display:false },
        tooltip:{
          enabled:true,
          backgroundColor:'rgba(20,20,20,0.9)',
          displayColors:false,
          callbacks:{ label: item => 'Leistung: ' + Math.round(item.raw*100) + '%' }
        }
      },
      scales:{
        x:{ type:'linear', min:0, ticks:{ stepSize:5 } },
        y:{ min:0.4, max:maxY, ticks:{ callback: v => Math.round(v*100) + '%' } }
      },
      interaction:{ mode:'nearest', intersect:false }
    }
  });
})();
<\/script>
</body>
</html>`;

  const newWin = window.open();
  newWin.document.open();
  newWin.document.write(html);
  newWin.document.close();
}
</script>
</body>
</html>
